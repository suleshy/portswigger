                                              ## What is the DOM?
                                              
# The Document Object Model (DOM) is a web browser's hierarchical representation of the elements on the page. 
# Websites can use JavaScript to manipulate the nodes and objects of the DOM, as well as their properties
# DOM-based vulnerabilities arise when a website contains JavaScript that takes an attacker-controllable value, known as a source, and passes it into a dangerous function, known as a sink. 

                                               ## Taint-flow vulnerabilities
                                               
====> Many DOM-based vulnerabilities can be traced back to problems with the way client-side code manipulates attacker-controllable data.                                                

    # What is taint flow?
    
====> To either exploit or mitigate these vulnerabilities, it is important to first familiarize yourself with the basics of taint flow between sources and sinks.


     <> SOURCES
     
# A source is a JavaScript property that accepts data that is potentially attacker-controlled.
# An example of a source is the location.search property because it reads input from the query string, which is relatively simple for an attacker to control
# Ultimately, any property that can be controlled by the attacker is a potential source.
# This includes the referring URL (exposed by the document.referrer string), the user's cookies (exposed by the document.cookie string), and web messages. 

   
   <> SINKS
   
# A sink is a potentially dangerous JavaScript function or DOM object that can cause undesirable effects if attacker-controlled data is passed to it.
# For example, the eval() function is a sink because it processes the argument that is passed to it as JavaScript.
# An example of an HTML sink is document.body.innerHTML because it potentially allows an attacker to inject malicious HTML and execute arbitrary JavaScript.




# Fundamentally, DOM-based vulnerabilities arise when a website passes data from a source to a sink, which then handles the data in an unsafe way in the context of the client's session. 

Example: 
                                                        goto = location.hash.slice(1)
                                                        if (goto.startsWith('https:')) {
                                                          location = goto;
                                                        }
Explanation:
-----> This is vulnerable to DOM-based open redirection because the location.hash source is handled in an unsafe way.  
-----> If the URL contains a hash fragment that starts with https:, this code extracts the value of the location.hash property and sets it as the location property of the window.

<> An attacker could exploit this vulnerability by constructing the following URL: 
--------> https://www.innocent-website.com/example#https://www.evil-user.net

                                                  ## Common sources
                                                  
# The following are typical sources that can be used to exploit a variety of taint-flow vulnerabilities: 

                                                      document.URL
                                                      document.documentURI
                                                      document.URLUnencoded
                                                      document.baseURI
                                                      location
                                                      document.cookie
                                                      document.referrer
                                                      window.name
                                                      history.pushState
                                                      history.replaceState
                                                      localStorage
                                                      sessionStorage
                                                      IndexedDB (mozIndexedDB, webkitIndexedDB, msIndexedDB)
                                                      Database
                                                      
                                                      
                                                      
                                                    ## DOM-based XSS
                                                    
# DOM-based XSS vulnerabilities usually arise when JavaScript takes data from an attacker-controllable source, such as the URL, and passes it to a sink that supports dynamic code execution, such as eval() or innerHTML.
# This enables attackers to execute malicious JavaScript, which typically allows them to hijack other users' accounts. 
# The most common source for DOM XSS is the URL, which is typically accessed with the window.location object. 

                                                    ## How to test for DOM-based cross-site scripting
                                                    
# The majority of DOM XSS vulnerabilities can be found quickly and reliably using Burp Suite's web vulnerability scanner.
# To test for DOM-based cross-site scripting manually, you generally need to use a browser with developer tools, such as Chrome.
# You need to work through each available source in turn, and test each one individually. 

                                      
                                                      ## Testing HTML sinks
                                                      
# To test for DOM XSS in an HTML sink, place a random alphanumeric string into the source (such as location.search), then use developer tools to inspect the HTML and find where your string appears. 

NOTE: Note that the browser's "View source" option won't work for DOM XSS testing because it doesn't take account of changes that have been performed in the HTML by JavaScript.

# Note that browsers behave differently with regards to URL-encoding, Chrome, Firefox, and Safari will URL-encode location.search and location.hash, while IE11 and Microsoft Edge (pre-Chromium) will not URL-encode these sources.

# If your data gets URL-encoded before being processed, then an XSS attack is unlikely to work.

                                                ## Testing JavaScript execution sinks
                                                
# Testing JavaScript execution sinks for DOM-based XSS is a little harder.
# With these sinks, your input doesn't necessarily appear anywhere within the DOM, so you can't search for it.
# Instead you'll need to use the JavaScript debugger to determine whether and how your input is sent to a sink.


                                             
                                                ## Testing for DOM XSS using DOM Invader
                                                
# Identifying and exploiting DOM XSS in the wild can be a tedious process, often requiring you to manually trawl through complex, minified JavaScript.
# If you use Burp's browser, however, you can take advantage of its built-in DOM Invader extension, which does a lot of the hard work for you.    


                                               ## Exploiting DOM XSS with different sources and sinks
# In principle, a website is vulnerable to DOM-based cross-site scripting if there is an executable path via which data can propagate from source to sink.

<> The document.write sink works with script elements, so you can use a simple payload, such as the one below: 
    ---> document.write('... <script>alert(document.domain)</script> ...');
 
 Example: "><svg onload=alert(1)>
 
NOTE: however, that in some situations the content that is written to document.write includes some surrounding context that you need to take account of in your exploit.
      For example, you might need to close some existing elements before using your JavaScript payload.  

    product?productId=1&storeId="></select><img%20src=1%20onerror=alert(1)>

<>  The innerHTML sink doesn't accept script elements on any modern browser, nor will svg onload events fire. This means you will need to use alternative elements like img or iframe.
<>  Event handlers such as onload and onerror can be used in conjunction with these elements. For example: 

Example: element.innerHTML='... <img src=1 onerror=alert(document.domain)> ...'


                                                    ## Sources and sinks in third-party dependencies
                                                    
# Modern web applications are typically built using a number of third-party libraries and frameworks, which often provide additional functions and capabilities for developers.
# It's important to remember that some of these are also potential sources and sinks for DOM XSS. 

     ## DOM XSS in jQuery
     
# If a JavaScript library such as jQuery is being used, look out for sinks that can alter DOM elements on the page.
# For instance, jQuery's attr() function can change the attributes of DOM elements.
# If data is read from a user-controlled source like the URL, then passed to the attr() function, then it may be possible to manipulate the value sent to cause XSS.

    Example:
    
    $(function() {
	$('#backLink').attr("href",(new URLSearchParams(window.location.search)).get('returnUrl'));
});

# You can exploit this by modifying the URL so that the location.search source contains a malicious JavaScript URL.
# After the page's JavaScript applies this malicious URL to the back link's href, clicking on the back link will execute it: 

      
?returnUrl=javascript:alert(document.domain)

# Another potential sink to look out for is jQuery's $() selector function, which can be used to inject malicious objects into the DOM. 

Example:
$(window).on('hashchange', function() {
	var element = $(location.hash);
	element[0].scrollIntoView();
});

====> As the hash is user controllable, an attacker could use this to inject an XSS vector into the $() selector sink.
# More recent versions of jQuery have patched this particular vulnerability by preventing you from injecting HTML into a selector when the input begins with a hash character (#). However, you may still find vulnerable code in the wild. 

-------> <iframe src="https://YOUR-LAB-ID.web-security-academy.net/#" onload="this.src+='<img src=x onerror=print()>'"></iframe>

# In this example, the src attribute points to the vulnerable page with an empty hash value. When the iframe is loaded, an XSS vector is appended to the hash, causing the hashchange event to fire. 


                                        ## DOM XSS in AngularJS
					
# If a framework like AngularJS is used, it may be possible to execute JavaScript without angle brackets or events. 
# When a site uses the ng-app attribute on an HTML element, it will be processed by AngularJS.
# In this case, AngularJS will execute JavaScript inside double curly braces that can occur directly in HTML or inside attributes. 


Example: {{$on.constructor('alert(1)')()}}	


                                           ## DOM XSS combined with reflected and stored data
# Some pure DOM-based vulnerabilities are self-contained within a single page.
# If a script reads some data from the URL and writes it to a dangerous sink, then the vulnerability is entirely client-side.

# However, sources aren't limited to data that is directly exposed by browsers - they can also originate from the website. 
# For example, websites often reflect URL parameters in the HTML response from the server.
# This is commonly associated with normal XSS, but it can also lead to reflected DOM XSS vulnerabilities.

# In a reflected DOM XSS vulnerability, the server processes data from the request, and echoes the data into the response.
# The reflected data might be placed into a JavaScript string literal, or a data item within the DOM, such as a form field.
# A script on the page then processes the reflected data in an unsafe way, ultimately writing it to a dangerous sink.

Example: eval('var data = "reflected string"');


							    var xhr = new XMLHttpRequest();
							    xhr.onreadystatechange = function() {
								if (this.readyState == 4 && this.status == 200) {
								    eval('var searchResultsObj = ' + this.responseText);
								    displaySearchResults(searchResultsObj);
								}
							    };
    
    
Payload: \"-alert(1)}//

# As you have injected a backslash and the site isn't escaping them, when the JSON response attempts to escape the opening double-quotes character, it adds a second backslash.
# An arithmetic operator (in this case the subtraction operator) is then used to separate the expressions before the alert() function is called. 
# Finally, a closing curly bracket and two forward slashes close the JSON object early and comment out what would have been the rest of the object.
# As a result, the response is generated as follows: 

								{"searchTerm":"\\"-alert(1)}//", "results":[]}
								

# Websites may also store data on the server and reflect it elsewhere.
# In a stored DOM XSS vulnerability, the server receives data from one request, stores it, and then includes the data in a later response.
# A script within the later response contains a sink which then processes the data in an unsafe way. 

Payload: element.innerHTML = comment.author

<><img src=1 onerror=alert(1)>

