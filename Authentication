                            ## VULNERABILITIES IN PASSWORD BASED-LOGIN
                      
                      ## 1. Username enumeration via different responses
                      
# 1.1 username enumiration via subtly different response
EXAMPLE: Grep - Extract, click Add. In the dialog that appears, scroll down through the response until you find the error message Invalid username or password..
          ----> When the attack is finished, notice that there is an additional column containing the error message you extracted.
                Sort the results using this column to notice that one of them is subtly different. 
   
 # 1.2 Username enumeration via response timing
 
EXAMPLE: Send this request to Burp Intruder and select the attack type to Pitchfork.Clear the default payload positions and add the X-Forwarded-For header. 
         When the attack finishes, at the top of the dialog, click Columns and select the Response received and Response completed options. These two columns are now displayed in the results table. 
         Notice that one of the response times was significantly longer than the others.
         
                     ## 2. Flawed brute-force protection
It is highly likely that a brute-force attack will involve many failed guesses before the attacker successfully compromises an account. 
The two most common ways of preventing brute-force attacks are: 
                      1. Locking the account that the remote user is trying to access if they make too many failed login attempts 
                      2. Blocking the remote user's IP address if they make too many login attempts in quick succession 

EXAMPLE: You might sometimes find that your IP is blocked if you fail to log in too many times. In some implementations, the counter for the number of failed attempts resets if the IP owner logs in successfully
         
                             
                             ## VULNERABILITIES IN MULTI-FACTOR AUTHENTICATION
                             
 NOTE: the full benefits of multi-factor authentication are only achieved by verifying multiple different factors. Verifying the same factor in two different ways is not true two-factor authentication. 
 
              # 1. Bypassing two-factor authentication
  If the user is first prompted to enter a password, and then prompted to enter a verification code on a separate page, the user is effectively in a "logged in" state before they have entered the verification code. 
  In this case, it is worth testing to see if you can directly skip to "logged-in only" pages after completing the first authentication step
  Occasionally, you will find that a website doesn't actually check whether or not you completed the second step before loading the page. 
  
  LAB1:  

    Log in to your own account. Your 2FA verification code will be sent to you by email. Click the Email client button to access your emails.
    Go to your account page and make a note of the URL.
    Log out of your account.
    Log in using the victim's credentials.
    When prompted for the verification code, manually change the URL to navigate to /my-account. The lab is solved when the page loads.

         # 2. Flawed two-factor verification logic
 Sometimes flawed logic in two-factor authentication means that after a user has completed the initial login step, the website doesn't adequately verify that the same user is completing the second step
 
                 #  For example, the user logs in with their normal credentials in the first step as follows:
                            POST /login-steps/first HTTP/1.1
                            Host: vulnerable-website.com
                            ...
                            username=carlos&password=qwerty
         

               # They are then assigned a cookie that relates to their account, before being taken to the second step of the login process:
                           HTTP/1.1 200 OK
                           Set-Cookie: account=carlos

                           GET /login-steps/second HTTP/1.1
                           Cookie: account=carlos



When submitting the verification code, the request uses this cookie to determine which account the user is trying to access:
                        POST /login-steps/second HTTP/1.1
                        Host: vulnerable-website.com
                        Cookie: account=carlos
                        ...
                        verification-code=123456
                        
 In this case, an attacker could log in using their own credentials but then change the value of the account cookie to any arbitrary username when submitting the verification code. 
 
                       POST /login-steps/second HTTP/1.1
                       Host: vulnerable-website.com
                       Cookie: account=victim-user
                       ...
                       verification-code=123456
                       
                       
                # 3.Brute-forcing 2FA verification codes
                
